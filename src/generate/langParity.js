const AdmZip = require("adm-zip");
const fs = require("fs");
const { forEachObject, projectPath } = require("../util/common");

function compareEditionLangs(options) {
    const { bedrockEditionLang, javaEditionLang, compareLangId, baseLangId } = options;
    const bedrockLangMap = {};
    const bedrockLangIdLookup = {};
    const javaLangMap = {};
    const javaLangIdLookup = {};
    const differences = [];
    forEachObject(bedrockEditionLang[baseLangId], (v, k) => {
        bedrockLangMap[v] = bedrockEditionLang[compareLangId][k];
        bedrockLangIdLookup[v] = k;
    });
    forEachObject(javaEditionLang[baseLangId], (v, k) => {
        javaLangMap[v] = javaEditionLang[compareLangId][k];
        javaLangIdLookup[v] = k;
    });
    forEachObject(bedrockLangMap, (v, k) => {
        if (k in javaLangMap) {
            const bedrockTranslation = v || "";
            const javaTranslation = javaLangMap[k] || "";
            const bedrockTranslationNoWhitespace = bedrockTranslation.replace(/\s/g, "");
            const javaTranslationNoWhitespace = javaTranslation.replace(/\s/g, "");
            if (bedrockTranslationNoWhitespace != javaTranslationNoWhitespace) {
                differences.push({
                    original: k,
                    translation: [bedrockTranslation, javaTranslation],
                    bedrockLangId: bedrockLangIdLookup[k],
                    javaLangId: javaLangIdLookup[k]
                });
            }
        }
    });
    return differences;
}

function writeLangParityPack(cx, options) {
    const { outputLangFile, outputPackFile, differences, overrideMap } = options;
    const langWithComment = {};
    const langLines = ["## This file is auto-generated by https://gitee.com/projectxero/caidlist"];
    differences.forEach((e) => {
        let comment = e.translation[0];
        if (e.javaLangId != e.bedrockLangId) {
            comment = e.javaLangId + " " + comment;
        }
        langWithComment[e.bedrockLangId] = [e.translation[1], comment];
    });
    if (overrideMap) {
        forEachObject(overrideMap, (v, k) => {
            if (v == "" && k.includes("*")) {
                const regexStr = k.replace(/[-/\\^$*+?.()|[\]{}]/g, "\\$&").replace(/\\\*/g, "(.*)");
                const regex = new RegExp(regexStr, "");
                forEachObject(langWithComment, (v, k) => {
                    if (regex.exec(k)) {
                        langWithComment[k] = [""];
                    }
                });
            } else {
                langWithComment[k] = [v];
            }
        });
    }
    forEachObject(langWithComment, (v, k) => {
        if (v[0].length) {
            langLines.push(`${k}=${v[0]}\t\t# ${v[1]}`);
        }
    });
    const langFileContent = langLines.join("\r\n");
    fs.writeFileSync(outputLangFile, langFileContent);
    if (outputPackFile) {
        const zip = new AdmZip();
        const versionArray = cx.coreVersion.split(".").map((e) => parseInt(e));
        const files = {
            "manifest.json": {
                format_version: 2,
                header: {
                    name: "基岩版翻译同步",
                    description: "同步 Java 版的部分翻译至基岩版",
                    uuid: "c7131e28-d145-4da9-8c8f-53fbd79cc028",
                    version: versionArray,
                    min_engine_version: [1, 12, 0]
                },
                modules: [
                    {
                        description: "同步 Java 版的部分翻译至基岩版",
                        type: "resources",
                        uuid: "d0760044-a2c3-4d08-9870-0f90b0de7e0c",
                        version: versionArray
                    }
                ]
            },
            "pack_icon.png": fs.readFileSync(__dirname + "/../assets/lang_parity_pack_icon.png"),
            "texts/languages.json": ["zh_CN"],
            "texts/zh_CN.lang": langFileContent
        };
        files["contents.json"] = {
            content: Object.keys(files).map((path) => ({ path }))
        };
        forEachObject(files, (content, fileName) => {
            if (typeof content != "string" && !Buffer.isBuffer(content)) {
                content = JSON.stringify(content);
            }
            zip.addFile(fileName, Buffer.from(content, "utf-8"));
        });
        fs.writeFileSync(outputPackFile, zip.toBuffer());
    }
}

module.exports = { compareEditionLangs, writeLangParityPack };
