<!DOCTYPE HTML>
<html lang="zh">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
        <title>Autocompletion Screen</title>
        <style>
            body {
                margin: 0px;
                overflow: hidden;
                background-color: transparent;
                font-family: "HYWenHei 65W", "思源黑体", monospace;
                font-size: 16px;
                display: flex;
                flex-direction: row;
            }
            body.no-obs {
                width: 100vw;
                height: 100vh;
                font-size: 20px;
                background: center/cover url(https://projectxero.top/ca/img/background2.png);
            }
            .leftbar {
                display: flex;
                flex: 0 0 auto;
                flex-direction: column;
            }
            .rightbar {
                display: flex;
                flex: 1;
                flex-direction: column;
            }
            .bar {
                border-radius: 10px;
                padding: 15px;
                background: rgba(255, 255, 255, 0.7);
                color: black;
            }
            .mojangles {
                font-family: "Mojangles", "HYWenHei 65W", "思源黑体", monospace;
            }
            .screenshot-container {
                display: flex;
                flex: 0 0 auto;
                margin: 20px 10px 10px 20px;
                width: 60vw;
                height: 27vw;
                justify-content: center;
                align-items: center;
            }
            .screenshot-available > .screenshot-nosignal {
                display: none;
            }
            .screenshot-nosignal {
                flex: 0 0 auto;
                font-size: 3em;
                text-align: center;
            }
            .screenshot {
                display: none;
                width: 100%;
                height: 100%;
                object-fit: contain;
                object-position: center center;
            }
            .screenshot-available > .screenshot {
                display: flex;
            }
            .logs {
                margin: 10px 10px 20px 20px;
                width: 60vw;
                flex: 1;
                overflow: hidden;
                white-space: pre-wrap;
                word-break: break-all;
                overflow-wrap: anywhere;
            }
            .explanation {
                margin: 20px 20px 10px 10px;
                flex: 1;
                overflow: hidden;
            }
            .explanation p {
                margin: 10px 0px 10px 0px;
                word-break: break-all;
            }
            .danmaku {
                margin: 0px 20px 20px 10px;
                flex: 0 0 auto;
                height: 30vh;
                overflow: hidden;
                white-space: pre-wrap;
            }
            .hidden {
                display: none;
            }
            .statusbar {
                margin: 10px 20px 20px 10px;
                flex: 0 0 auto;
                overflow: hidden;
                word-break: break-all;
                white-space: pre-wrap;
                overflow-wrap: anywhere;
            }
        </style>
        <script>
            window.addEventListener('error', (error) => {
                document.write(error.message);
            });
        </script>
        <script type="text/javascript" src="https://projectxero.top/js/dynamic-marquee.2.3.4.js"></script>
        <script type="text/javascript" src="https://projectxero.top/js/jmuxer.js"></script>
    </head>
    <body>
        <div class="leftbar">
            <div class="screenshot-container bar">
                <div class="screenshot-nosignal">正在生成世界</div>
                <video class="screenshot" src="" alt="screenshot"></video>
            </div>
            <div class="logs bar mojangles"></div>
        </div>
        <div class="rightbar">
            <div class="explanation bar"></div>
            <div class="statusbar bar"></div>
            <div class="danmaku bar"></div>
        </div>
        <script type="module">
            /* global dynamicMarquee */
            // const screenshotContainer = document.querySelector('.screenshot-container');
            // const screenshotEl = document.querySelector('.screenshot');
            const logsEl = document.querySelector('.logs');
            const explanationEl = document.querySelector('.explanation');
            const statusBarEl = document.querySelector('.statusbar');
            const danmakuEl = document.querySelector('.danmaku');
            const versionNameMap = {
                beta: '测试版/预览版',
                release: '正式版',
                netease: '中国版',
                netease_dev: '中国版测试版',
                education: '教育版',
                preview_win: '预览版（Windows）',
                bds_preview: '专用服务器预览版',
                bds: '专用服务器正式版',
                dev: '预览版开发版',
                release_dev: '正式版开发版',
                education_dev: '教育版开发版',
                bds_dev: '专用服务器预览版开发版',
                bds_release_dev: '专用服务器正式版开发版'
            };
            const branchNameMap = {
                vanilla: '原版',
                education: '教育版',
                experiment: '实验性玩法',
                gametest: 'Script API',
                translator: '翻译专用',
                documentation: '文档',
                langParity: '译名比较'
            };
            const enumNameMap = {
                blocks: '方块(用于 setblock、fill 等命令的方块 ID)',
                items: '物品(用于 give、clear 等命令的物品 ID)',
                entities: '实体(用于 type 选择器的实体 ID)',
                summonable_entities: '可召唤实体(用于 summon 命令的实体 ID)',
                effects: '状态效果(用于 effect 命令的状态效果 ID)',
                enchantments: '魔咒(用于 enchant 命令的魔咒 ID)',
                gamerules: '游戏规则(用于 gamerule 命令的游戏规则 ID)',
                locations: '结构(用于 locate 命令的结构 ID)',
                biomes: '生物群系(用于 locate 命令的生物群系 ID)',
                mobevents: '生物事件(用于 mobevent 命令的生物事件 ID)',
                entity_slots: '槽位(用于 replaceitem 命令等的槽位 ID)',
                selectors: '目标选择器参数',
                loot_tools: '战利品工具表(用于 loot 命令的工具选项)',
                damage_causes: '伤害类型(用于 damage 命令的伤害类型 ID)',
                item_with_aliases: '物品(包含别名，可用于 give、clear 等命令)',
                features_and_rules: '地物与地物规则(用于 placefeature 命令的地物 ID 和地物规则 ID)',
                input_permissions: '操作输入权限(用于 inputpermission 命令的输入权限 ID)',
                camera_presets: '摄像机预设(用于 camera 命令的摄像机预设 ID)',
                recipes: '配方(用于 recipe 命令的配方 ID)',
                abilities: '能力(用于教育版 ability 命令的能力 ID)',
                options: '选项',
                particle_types: '粒子类型',
                features: '地物',
                feature_rules: '地物规则',
                server_tests: '服务器测试',
                unit_tests: '单元测试',
                functional_tests: '功能测试'
            };
            let sessionId = null;
            const logs = [];
            let lastLogTime = Date.now();
            let lastActiveTime = Date.now();
            const danmakus = [];
            let danmakuOnline = false;
            let obsStreaming = null;
            function dateTimeString(d) {
                const date = [d.getFullYear(), '年', d.getMonth() + 1, '月', d.getDate(), '日'];
                const time = [d.getHours(), d.getMinutes(), d.getSeconds()].map((e) => String(e).padStart(2, '0'));
                return `${date.join('')} ${time.join(':')}`;
            }
            function timeLeftString(seconds) {
                const floorSeconds = Math.floor(seconds);
                const sec = (floorSeconds % 60).toFixed(0);
                const min = (Math.floor(floorSeconds / 60) % 60).toFixed(0);
                const hr = Math.floor(floorSeconds / 3600).toFixed(0);
                if (floorSeconds >= 3600) {
                    return `${hr}小时${min.padStart(2, '0')}分${sec.padStart(2, '0')}秒`;
                } if (floorSeconds >= 60) {
                    return `${min}分${sec.padStart(2, '0')}秒`;
                }
                return `${sec}秒`;
            }
            async function fetchJSON(input, timeout, options) {
                const controller = new AbortController();
                let handle;
                if (timeout > 0) {
                    handle = setTimeout(() => controller.abort(new Error(`Request timeout exceeded ${timeout}ms.`)), timeout);
                }
                try {
                    const res = await fetch(input, { ...options, signal: controller.signal });
                    return await res.json();
                } finally {
                    if (handle) {
                        clearTimeout(handle);
                    }
                }
            }
            async function tryInitOBS() {
                try {
                    const obs = window.obsstudio;
                    const controlLevel = await new Promise((resolve) => {
                        obs.getControlLevel(resolve);
                    });
                    if (controlLevel < 5) {
                        throw new Error('Permission denied');
                    }
                    const status = await new Promise((resolve) => {
                        obs.getStatus(resolve);
                    });
                    obsStreaming = status.streaming;
                    window.addEventListener('obsStreamingStarted', () => {
                        obsStreaming = true;
                        lastActiveTime = Date.now();
                    });
                    window.addEventListener('obsStreamingStopped', () => {
                        obsStreaming = false;
                    });
                } catch (err) {
                    console.warn('OBS api is not available, skipped...', err);
                }
            }
            if (window.obsstudio) {
                tryInitOBS();
            } else {
                document.body.classList.add('no-obs');
            }
            async function updateStatus() {
                let hb = { sessionId: null };
                let success = false;
                try {
                    hb = await fetchJSON(`http://localhost:19333/heartbeat?since=${logs.length}`, 1000);
                    success = true;
                } catch (err) { /* ignore */ }
                const text = [];
                text.push(`时间：${dateTimeString(new Date())}`);
                if (hb.version) {
                    const versionName = versionNameMap[hb.version] || '未知版本';
                    const branchName = branchNameMap[hb.branch] || '未知分支';
                    text.push(`项目：${versionName}（${hb.packageVersion}）- ${branchName}`);
                }
                if (hb.enumId) {
                    text.push(`条目：(${hb.jobIndex + 1}/${hb.jobCount})${enumNameMap[hb.enumId.replace(/\s+/g, '_')] || '未知条目'}`);
                }
                if (hb.autocompletion) {
                    text.push(`识别结果：${hb.autocompletion}`);
                }
                if (hb.resultLength) {
                    const speed = (1000 / hb.stepSpent).toFixed(1);
                    const fps = ((hb.reactFrameCount / hb.reactInterval) * 1000).toFixed(1);
                    text.push(`识别速度：${speed}条/秒（${hb.reactFrameCount}帧/条 ${fps} fps 滞后${hb.droppedCount}条）`);
                    if (hb.approxLength > 0) {
                        const averageSpeed = (1000 / hb.stepSpentAvg).toFixed(2);
                        text.push(`条目进度：${hb.percentage}% (${hb.resultLength}/${hb.approxLength})`);
                        text.push(`剩余时间：约${timeLeftString(hb.timeLeft / 1000)} - 平均${averageSpeed}条/秒`);
                        text.push(`预计结束时间：${dateTimeString(new Date(hb.estTime))}`);
                    } else {
                        text.push(`已识别：${hb.resultLength} 条目`);
                    }
                }
                if (hb.retryCount) {
                    text.push(`上次识别校验失败，正在进行第${hb.retryCount + 1}次识别`);
                }
                if (hb.sessionId !== sessionId) {
                    logs.length = 0;
                    sessionId = hb.sessionId;
                }
                if (hb.logs && hb.logs.length) {
                    logs.push(...hb.logs);
                    logsEl.innerHTML = logs.slice(Math.max(logs.length - (logs.length % 100) - 30, 0)).join('\n');
                    logsEl.scroll({
                        top: logsEl.scrollHeight,
                        left: 0,
                        behavior: Date.now() - lastLogTime < 200 || hb.logs.length > 10 ? 'auto' : 'smooth'
                    });
                    lastLogTime = Date.now();
                    lastActiveTime = Date.now();
                }
                if (!sessionId) {
                    text.push('状态服务器：离线');
                }
                if (!danmakuOnline) {
                    text.push('弹幕姬：离线');
                }
                if (obsStreaming) {
                    const unresponsibleSeconds = (Date.now() - lastActiveTime) / 1000;
                    if (unresponsibleSeconds > 60) {
                        text.push(`将在${timeLeftString(360 - unresponsibleSeconds)}后自动结束直播`);
                    }
                    if (unresponsibleSeconds > 360) {
                        window.obsstudio.stopStreaming();
                    }
                }
                statusBarEl.innerHTML = text.join('\n');
                setTimeout(updateStatus, success ? 100 : 1000);
            }
            async function updateDanmaku() {
                let lines = [];
                try {
                    lines = await fetchJSON(`http://localhost:19334/lines?since=${danmakus.length}`, 300);
                    danmakuOnline = true;
                } catch (err) {
                    danmakuOnline = false;
                }
                if (lines.length) {
                    danmakus.push(...lines);
                    danmakuEl.innerHTML = danmakus.join('\n');
                }
                danmakuEl.scroll({
                    top: danmakuEl.scrollHeight,
                    left: 0,
                    behavior: lines.length > 10 ? 'auto' : 'smooth'
                });
                if (danmakuOnline) {
                    danmakuEl.classList.remove('hidden');
                } else {
                    danmakuEl.classList.add('hidden');
                }
                setTimeout(updateDanmaku, danmakuOnline ? 1000 : 10000);
            }
            function loadVideo() {
                // Broken codes
                //
                // const converter = new H264Converter(screenshotEl, 30, 6);
                // const abortController = new AbortController();
                // fetch('http://localhost:19333/stream', { signal: abortController.signal }).then((res) => {
                //     if (res.body) {
                //         screenshotContainer.classList.add('screenshot-available');
                //         const reader = res.body.getReader();
                //         const promise = reader.read().then(function processResult(result) {
                //             function decode(value) {
                //                 converter.appendRawData(value);
                //             }
                //             if (result.done) {
                //                 decode([]);
                //                 console.log('Video Stream is done.');
                //                 return Promise.resolve();
                //             }
                //             decode(result.value);
                //             return reader.read().then(processResult);
                //         });
                //         converter.play();
                //         return promise;
                //     }
                //     return null;
                // }).catch((err) => {
                //     console.error('Video Stream Request error', err);
                //     abortController.abort(err);
                // }).finally(() => {
                //     screenshotContainer.classList.remove('screenshot-available');
                //     setTimeout(loadVideo, 3000);
                // });
            }
            updateStatus();
            updateDanmaku();
            loadVideo();
            const marquee = new dynamicMarquee.Marquee(explanationEl, {
                rate: -20 / devicePixelRatio,
                upDown: true,
                startOnScreen: true
            });
            const explanationTexts = [
                ['这是在做什么？', '获取Minecraft基岩版最新版本的ID表，我叫它爬ID表。'],
                ['是什么原理？', '模拟键盘按Tab键然后对聊天框进行文字图像识别。'],
                ['有什么用？', '扔到命令助手和MCBEID表里，顺带完善MC更新记录。'],
                [
                    '纯路人。为什么要做这个？',
                    '众所周知命令里有很多英文的ID，例如方块ID。有个ID与中文的对照表就很方便。',
                    '目前正在做的就是通过一些方法提取这个对照表的数据。'
                ],
                ['我在哪里能找到你上面说的对照表？', 'MCBEID表，https://ca.projectxero.top/idlist/'],
                [
                    '我想要你爬的数据，请问哪里有白嫖？',
                    '<span style="text-decoration: line-through">MCBEID表的关于页面有写。</span> 自己爬。'
                ],
                [
                    '你手机卡成这样了，没事吗？',
                    '这个只是截图帧率低，大概低于10fps，实际上手机非常流畅，30fps不在话下。'
                ],
                [
                    '这个是每周的常驻节目吗？',
                    '测试版一般会在每周的周三或周四发布，我会在更新当天或次日进行直播爬ID表，一次直播三个小时左右。'
                ],
                [
                    '我能来这个直播间干什么？',
                    '<span style="text-decoration: line-through">了解ID的变化情况。</span>欢迎来弹幕聊天啊，听听歌也行。',
                    '但<span style="font-weight: bold">请不要在直播间里赠送付费的礼物或者上舰</span>。'
                ],
                ['命令助手呢？啥时候更新？', '已经更新了哦，请参见原作者的爱发电主页~'],
                ['你的手机还能同时玩别的游戏的吗？', '这只是电脑画面的映射。给枯燥的直播加点趣味。']
            ];
            dynamicMarquee.loop(
                marquee,
                explanationTexts.map((e) => () => {
                    const el = document.createElement('p');
                    el.innerHTML = `问：${e[0]}<br />答：${e.slice(1).join('')}`;
                    return el;
                })
            );
        </script>
    </body>
</html>
