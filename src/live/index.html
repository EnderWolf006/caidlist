<!DOCTYPE HTML>
<html lang="zh">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
        <title>Autocompletion Screen</title>
        <style>
            body {
                margin: 0px;
                overflow: hidden;
                background-color: transparent;
                font-family: "HYWenHei 65W", "思源黑体", monospace;
                font-size: 16px;
                display: flex;
                flex-direction: row;
            }
            .leftbar {
                display: flex;
                flex: 0 0 auto;
                flex-direction: column;
            }
            .rightbar {
                display: flex;
                flex: 1;
                flex-direction: column;
            }
            .bar {
                border-radius: 10px;
                padding: 15px;
                background: rgba(255, 255, 255, 0.7);
                color: black;
            }
            .night-mode .bar {
                background: rgba(0, 0, 0, 0.5);
                color: white;
            }
            .mojangles {
                font-family: "Mojangles", "HYWenHei 65W", "思源黑体", monospace;
            }
            .screenshot-container {
                display: flex;
                flex: 0 0 auto;
                margin: 20px 10px 10px 20px;
                width: 60vw;
                height: 27vw;
                justify-content: center;
                align-items: center;
            }
            .screenshot-available > .screenshot-nosignal {
                display: none;
            }
            .screenshot-nosignal {
                flex: 0 0 auto;
                font-size: 3em;
                text-align: center;
            }
            .screenshot {
                display: none;
                width: 100%;
                height: 100%;
                object-fit: contain;
                object-position: center center;
            }
            .screenshot-available > .screenshot {
                display: flex;
            }
            .logs {
                margin: 10px 10px 20px 20px;
                width: 60vw;
                flex: 1;
                overflow: hidden;
                white-space: pre-wrap;
                word-break: break-all;
                overflow-wrap: anywhere;
            }
            .explanation {
                margin: 20px 20px 10px 10px;
                flex: 1;
                overflow: hidden;
            }
            .explanation p {
                margin: 10px 0px 10px 0px;
                word-break: break-all;
            }
            .danmaku {
                margin: 10px 20px 20px 10px;
                flex: 0 0 auto;
                height: 30vh;
                overflow: hidden;
                white-space: pre-wrap;
            }
            .statusbar {
                margin: 10px 20px 10px 10px;
                flex: 0 0 auto;
                overflow: hidden;
                word-break: break-all;
                white-space: pre-wrap;
                overflow-wrap: anywhere;
            }
        </style>
        <script>
            window.addEventListener('error', (error) => {
                document.write(error.message);
            });
        </script>
        <script type="text/javascript" src="https://projectxero.top/js/dynamic-marquee.2.3.4.js"></script>
    </head>
    <body>
        <div class="leftbar">
            <div class="screenshot-container bar">
                <div class="screenshot-nosignal">正在生成世界</div>
                <img class="screenshot" src="" alt="screenshot">
            </div>
            <div class="logs bar mojangles"></div>
        </div>
        <div class="rightbar">
            <div class="explanation bar"></div>
            <div class="statusbar bar"></div>
            <div class="danmaku bar"></div>
        </div>
        <script>
            /* global dynamicMarquee */
            const screenshotContainer = document.querySelector('.screenshot-container');
            const screenshotEl = document.querySelector('.screenshot');
            const logsEl = document.querySelector('.logs');
            const explanationEl = document.querySelector('.explanation');
            const statusBarEl = document.querySelector('.statusbar');
            const danmakuEl = document.querySelector('.danmaku');
            const versionNameMap = {
                beta: '测试版',
                release: '正式版',
                netease_dev: '中国版测试版'
            };
            const branchNameMap = {
                vanilla: '原版',
                education: '教育版',
                experiment: '实验性玩法'
            };
            const enumNameMap = {
                blocks: '方块（用于 setblock、fill 等命令的方块 ID）',
                items: '物品（用于 give、clear 等命令的物品 ID）',
                entities: '实体（用于 type 选择器的实体 ID）',
                'summonable entities': '可召唤实体（用于 summon 命令的实体 ID）',
                effects: '状态效果（用于 effect 命令的状态效果 ID）',
                enchantments: '魔咒（用于 enchant 命令的魔咒 ID）',
                gamerules: '游戏规则（用于 gamerule 命令的游戏规则 ID）',
                locations: '结构（用于 locate 命令的结构 ID）',
                biomes: '生物群系（用于 locate 命令的生物群系 ID）',
                mobevents: '生物事件（用于 mobevent 命令的生物事件 ID）',
                'entity slots': '栏位（用于 replaceitem 命令等的栏位 ID）',
                selectors: '目标选择器参数',
                'loot tools': '战利品工具表（用于 loot 命令的工具选项）',
                'damage causes': '伤害来源（用于 damage 命令的伤害来源 ID）',
                'item with aliases': '物品（包含别名，可用于 give、clear 等命令）',
                features: '地物与地物规则（用于 placefeature 命令）',
                abilities: '能力（用于教育版 ability 命令的能力 ID）'
            };
            let sessionId = null;
            let screenshotId = null;
            const logs = [];
            let lastLogTime = Date.now();
            let lastActiveTime = Date.now();
            const danmakus = [];
            let danmakuOnline = false;
            let obsStreaming = null;
            function dateTimeString(d) {
                const date = [d.getFullYear(), '年', d.getMonth() + 1, '月', d.getDate(), '日'];
                const time = [d.getHours(), d.getMinutes(), d.getSeconds()].map((e) => String(e).padStart(2, '0'));
                return `${date.join('')} ${time.join(':')}`;
            }
            function timeLeftString(seconds) {
                const floorSeconds = Math.floor(seconds);
                const sec = (floorSeconds % 60).toFixed(0);
                const min = (Math.floor(floorSeconds / 60) % 60).toFixed(0);
                const hr = Math.floor(floorSeconds / 3600).toFixed(0);
                if (floorSeconds >= 3600) {
                    return `${hr}小时${min.padStart(2, '0')}分${sec.padStart(2, '0')}秒`;
                } if (floorSeconds >= 60) {
                    return `${min}分${sec.padStart(2, '0')}秒`;
                }
                return `${sec}秒`;
            }
            async function tryInitOBS() {
                try {
                    const obs = window.obsstudio;
                    const controlLevel = await new Promise((resolve) => {
                        obs.getControlLevel(resolve);
                    });
                    if (controlLevel < 5) {
                        throw new Error('Permission denied');
                    }
                    const status = await new Promise((resolve) => {
                        obs.getStatus(resolve);
                    });
                    obsStreaming = status.streaming;
                    window.addEventListener('obsStreamingStarted', () => {
                        obsStreaming = true;
                        lastActiveTime = Date.now();
                    });
                    window.addEventListener('obsStreamingStopped', () => {
                        obsStreaming = false;
                    });
                } catch (err) {
                    console.warn('OBS api is not available, skipped...', err);
                }
            }
            if (window.obsstudio) {
                tryInitOBS();
            }
            async function updateStatus() {
                let hb = { sessionId: null };
                let success = false;
                try {
                    hb = await (await fetch(`http://localhost:19333/heartbeat?since=${logs.length}`)).json();
                    success = true;
                } catch (err) { /* ignore */ }
                const text = [];
                text.push(`时间：${dateTimeString(new Date())}`);
                if (hb.version) {
                    const versionName = versionNameMap[hb.version];
                    const branchName = branchNameMap[hb.branch];
                    text.push(`项目：${versionName}（${hb.packageVersion}）- ${branchName}`);
                }
                if (hb.enumId) {
                    text.push(`条目：${enumNameMap[hb.enumId]}`);
                }
                if (hb.autocompletion) {
                    text.push(`识别结果：${hb.autocompletion}`);
                }
                if (hb.resultLength) {
                    const speed = (1000 / hb.stepSpent).toFixed(1);
                    const fps = ((hb.reactFrameCount / hb.reactInterval) * 1000).toFixed(1);
                    text.push(`识别速度：${speed}条/秒（${hb.reactFrameCount}张/条 ${fps} fps）`);
                    if (hb.approxLength) {
                        const averageSpeed = (1000 / hb.stepSpentAvg).toFixed(2);
                        text.push(`条目进度：${hb.percentage}% (${hb.resultLength}/${hb.approxLength})`);
                        text.push(`剩余时间：约${timeLeftString(hb.timeLeft / 1000)} - 平均${averageSpeed}条/秒`);
                        text.push(`预计结束时间：${dateTimeString(new Date(hb.estTime))}`);
                    } else {
                        text.push(`已识别：${hb.resultLength} 条目`);
                    }
                }
                if (hb.sessionId !== sessionId) {
                    screenshotId = null;
                    logs.length = 0;
                    sessionId = hb.sessionId;
                    screenshotContainer.classList.remove('screenshot-available');
                }
                if (hb.screenshotId && hb.screenshotId !== screenshotId) {
                    if (screenshotId == null) {
                        screenshotContainer.classList.add('screenshot-available');
                    }
                    screenshotId = hb.screenshotId;
                    screenshotEl.src = `http://localhost:19333/screenshot?id=${screenshotId}`;
                }
                if (hb.logs && hb.logs.length) {
                    logs.push(...hb.logs);
                    logsEl.innerHTML = logs.slice(Math.max(logs.length - (logs.length % 100) - 30, 0)).join('\n');
                    logsEl.scroll({
                        top: logsEl.scrollHeight,
                        left: 0,
                        behavior: Date.now() - lastLogTime < 200 || hb.logs.length > 10 ? 'auto' : 'smooth'
                    });
                    lastLogTime = Date.now();
                    lastActiveTime = Date.now();
                }
                if (!sessionId) {
                    text.push('状态服务器：离线');
                }
                if (!danmakuOnline) {
                    text.push('弹幕姬：离线');
                }
                if (obsStreaming) {
                    const unresponsibleSeconds = (Date.now() - lastActiveTime) / 1000;
                    if (unresponsibleSeconds > 60) {
                        text.push(`将在${timeLeftString(360 - unresponsibleSeconds)}后自动结束直播`);
                    }
                    if (unresponsibleSeconds > 360) {
                        window.obsstudio.stopStreaming();
                    }
                }
                statusBarEl.innerHTML = text.join('\n');
                setTimeout(updateStatus, success ? 100 : 1000);
            }
            async function updateDanmaku() {
                let lines = [];
                try {
                    lines = await (await fetch(`http://localhost:19334/lines?since=${danmakus.length}`)).json();
                    danmakuOnline = true;
                } catch (err) {
                    danmakuOnline = false;
                }
                if (lines.length) {
                    danmakus.push(...lines);
                    danmakuEl.innerHTML = danmakus.join('\n');
                }
                danmakuEl.scroll({
                    top: danmakuEl.scrollHeight,
                    left: 0,
                    behavior: lines.length > 10 ? 'auto' : 'smooth'
                });
                setTimeout(updateDanmaku, 1000);
            }
            updateStatus();
            updateDanmaku();
            const marquee = new dynamicMarquee.Marquee(explanationEl, {
                rate: -20 / devicePixelRatio,
                upDown: true,
                startOnScreen: true
            });
            const explanationTexts = [
                ['这是在做什么？', '获取Minecraft基岩版最新版本的ID表，我叫它爬ID表。'],
                ['是什么原理？', '模拟键盘按Tab键然后对聊天框进行文字图像识别。'],
                ['有什么用？', '扔到命令助手和MCBEID表里，顺带完善MC更新记录。'],
                [
                    '纯路人。为什么要做这个？',
                    '众所周知命令里有很多英文的ID，例如方块ID。有个ID与中文的对照表就很方便。',
                    '目前正在做的就是通过一些方法提取这个对照表的数据。'
                ],
                ['我在哪里能找到你上面说的对照表？', 'MCBEID表，https://ca.projectxero.top/idlist/'],
                [
                    '我想要你爬的数据，请问哪里有白嫖？',
                    '<span style="text-decoration: line-through">MCBEID表的关于页面有写。</span> 自己爬。'
                ],
                [
                    '你手机卡成这样了，没事吗？',
                    '这个只是截图帧率低，大概低于10fps，实际上手机非常流畅，30fps不在话下。'
                ],
                [
                    '这个是每周的常驻节目吗？',
                    '测试版一般会在每周的周三或周四发布，我会在更新当天或次日进行直播爬ID表，一次直播两个小时左右。'
                ],
                [
                    '我能来这个直播间干什么？',
                    '<span style="text-decoration: line-through">了解ID的变化情况。</span>欢迎来弹幕聊天啊，听听歌也行。',
                    '但<span style="font-weight: bold">请不要在直播间里赠送付费的礼物或者上舰</span>。'
                ],
                ['命令助手呢？你啥时候更新？', '无限期暂停更新中，别催了，催了也没用'],
                ['为什么UP主的主页打不开？', '我也不清楚啊，不如关注一下UP主翻翻动态试试？']
            ];
            dynamicMarquee.loop(
                marquee,
                explanationTexts.map((e) => () => {
                    const el = document.createElement('p');
                    el.innerHTML = `问：${e[0]}<br />答：${e.slice(1).join('')}`;
                    return el;
                })
            );
        </script>
    </body>
</html>
